(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/overlay'), require('@angular/common'), require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@angular/cdk/portal'), require('@angular/cdk/a11y')) :
    typeof define === 'function' && define.amd ? define('ngx-contextmenu', ['exports', '@angular/cdk/overlay', '@angular/common', '@angular/core', 'rxjs', 'rxjs/operators', '@angular/cdk/portal', '@angular/cdk/a11y'], factory) :
    (global = global || self, factory(global['ngx-contextmenu'] = {}, global.ng.cdk.overlay, global.ng.common, global.ng.core, global.rxjs, global.rxjs.operators, global.ng.cdk.portal, global.ng.cdk.a11y));
}(this, (function (exports, overlay, common, core, rxjs, operators, portal, a11y) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ContextMenuItemDirective = /** @class */ (function () {
        function ContextMenuItemDirective(template, elementRef) {
            this.template = template;
            this.elementRef = elementRef;
            this.divider = false;
            this.enabled = true;
            this.passive = false;
            this.visible = true;
            this.execute = new core.EventEmitter();
            this.isActive = false;
        }
        Object.defineProperty(ContextMenuItemDirective.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this.passive ||
                    this.divider ||
                    !this.evaluateIfFunction(this.enabled, this.currentItem);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @param {?} item
         * @return {?}
         */
        ContextMenuItemDirective.prototype.evaluateIfFunction = /**
         * @param {?} value
         * @param {?} item
         * @return {?}
         */
        function (value, item) {
            if (value instanceof Function) {
                return value(item);
            }
            return value;
        };
        /**
         * @return {?}
         */
        ContextMenuItemDirective.prototype.setActiveStyles = /**
         * @return {?}
         */
        function () {
            this.isActive = true;
        };
        /**
         * @return {?}
         */
        ContextMenuItemDirective.prototype.setInactiveStyles = /**
         * @return {?}
         */
        function () {
            this.isActive = false;
        };
        /**
         * @param {?} item
         * @param {?=} $event
         * @return {?}
         */
        ContextMenuItemDirective.prototype.triggerExecute = /**
         * @param {?} item
         * @param {?=} $event
         * @return {?}
         */
        function (item, $event) {
            if (!this.evaluateIfFunction(this.enabled, item)) {
                return;
            }
            this.execute.emit({ event: $event, item: item });
        };
        ContextMenuItemDirective.decorators = [
            { type: core.Directive, args: [{
                        /* tslint:disable:directive-selector-type */
                        selector: '[contextMenuItem]',
                    },] }
        ];
        /** @nocollapse */
        ContextMenuItemDirective.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: core.ElementRef }
        ]; };
        ContextMenuItemDirective.propDecorators = {
            subMenu: [{ type: core.Input }],
            divider: [{ type: core.Input }],
            enabled: [{ type: core.Input }],
            passive: [{ type: core.Input }],
            visible: [{ type: core.Input }],
            execute: [{ type: core.Output }]
        };
        return ContextMenuItemDirective;
    }());
    if (false) {
        /** @type {?} */
        ContextMenuItemDirective.prototype.subMenu;
        /** @type {?} */
        ContextMenuItemDirective.prototype.divider;
        /** @type {?} */
        ContextMenuItemDirective.prototype.enabled;
        /** @type {?} */
        ContextMenuItemDirective.prototype.passive;
        /** @type {?} */
        ContextMenuItemDirective.prototype.visible;
        /** @type {?} */
        ContextMenuItemDirective.prototype.execute;
        /** @type {?} */
        ContextMenuItemDirective.prototype.currentItem;
        /** @type {?} */
        ContextMenuItemDirective.prototype.isActive;
        /** @type {?} */
        ContextMenuItemDirective.prototype.template;
        /** @type {?} */
        ContextMenuItemDirective.prototype.elementRef;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CONTEXT_MENU_OPTIONS = new core.InjectionToken('CONTEXT_MENU_OPTIONS');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function ILinkConfig() { }
    if (false) {
        /** @type {?} */
        ILinkConfig.prototype.click;
        /** @type {?|undefined} */
        ILinkConfig.prototype.enabled;
        /** @type {?} */
        ILinkConfig.prototype.html;
    }
    /** @type {?} */
    var ARROW_LEFT_KEYCODE = 37;
    var ContextMenuContentComponent = /** @class */ (function () {
        function ContextMenuContentComponent(changeDetector, elementRef, options) {
            this.changeDetector = changeDetector;
            this.elementRef = elementRef;
            this.options = options;
            this.menuItems = [];
            this.isLeaf = false;
            this.execute = new core.EventEmitter();
            this.openSubMenu = new core.EventEmitter();
            this.closeLeafMenu = new core.EventEmitter();
            this.closeAllMenus = new core.EventEmitter();
            this.autoFocus = false;
            this.useBootstrap4 = false;
            this.subscription = new rxjs.Subscription();
            if (options) {
                this.autoFocus = options.autoFocus;
                this.useBootstrap4 = options.useBootstrap4;
            }
        }
        /**
         * @return {?}
         */
        ContextMenuContentComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.menuItems.forEach((/**
             * @param {?} menuItem
             * @return {?}
             */
            function (menuItem) {
                menuItem.currentItem = _this.item;
                _this.subscription.add(menuItem.execute.subscribe((/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) {
                    return _this.execute.emit(__assign({}, event, { menuItem: menuItem }));
                })));
            }));
            /** @type {?} */
            var queryList = new core.QueryList();
            queryList.reset(this.menuItems);
            this._keyManager = new a11y.ActiveDescendantKeyManager(queryList).withWrap();
        };
        /**
         * @return {?}
         */
        ContextMenuContentComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.autoFocus) {
                setTimeout((/**
                 * @return {?}
                 */
                function () { return _this.focus(); }));
            }
            this.overlay.updatePosition();
        };
        /**
         * @return {?}
         */
        ContextMenuContentComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.subscription.unsubscribe();
        };
        /**
         * @return {?}
         */
        ContextMenuContentComponent.prototype.focus = /**
         * @return {?}
         */
        function () {
            if (this.autoFocus) {
                this.menuElement.nativeElement.focus();
            }
        };
        /**
         * @param {?} $event
         * @return {?}
         */
        ContextMenuContentComponent.prototype.stopEvent = /**
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            $event.stopPropagation();
        };
        /**
         * @param {?} menuItem
         * @return {?}
         */
        ContextMenuContentComponent.prototype.isMenuItemEnabled = /**
         * @param {?} menuItem
         * @return {?}
         */
        function (menuItem) {
            return this.evaluateIfFunction(menuItem && menuItem.enabled);
        };
        /**
         * @param {?} menuItem
         * @return {?}
         */
        ContextMenuContentComponent.prototype.isMenuItemVisible = /**
         * @param {?} menuItem
         * @return {?}
         */
        function (menuItem) {
            return this.evaluateIfFunction(menuItem && menuItem.visible);
        };
        /**
         * @param {?} value
         * @return {?}
         */
        ContextMenuContentComponent.prototype.evaluateIfFunction = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value instanceof Function) {
                return value(this.item);
            }
            return value;
        };
        /**
         * @param {?} link
         * @return {?}
         */
        ContextMenuContentComponent.prototype.isDisabled = /**
         * @param {?} link
         * @return {?}
         */
        function (link) {
            return link.enabled && !link.enabled(this.item);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        ContextMenuContentComponent.prototype.onKeyEvent = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (!this.isLeaf) {
                return;
            }
            this._keyManager.onKeydown(event);
        };
        /**
         * @param {?=} event
         * @return {?}
         */
        ContextMenuContentComponent.prototype.keyboardOpenSubMenu = /**
         * @param {?=} event
         * @return {?}
         */
        function (event) {
            if (!this.isLeaf) {
                return;
            }
            this.cancelEvent(event);
            /** @type {?} */
            var menuItem = this.menuItems[this._keyManager.activeItemIndex];
            if (menuItem) {
                this.onOpenSubMenu(menuItem);
            }
        };
        /**
         * @param {?=} event
         * @return {?}
         */
        ContextMenuContentComponent.prototype.keyboardMenuItemSelect = /**
         * @param {?=} event
         * @return {?}
         */
        function (event) {
            if (!this.isLeaf) {
                return;
            }
            this.cancelEvent(event);
            /** @type {?} */
            var menuItem = this.menuItems[this._keyManager.activeItemIndex];
            if (menuItem) {
                this.onMenuItemSelect(menuItem, event);
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        ContextMenuContentComponent.prototype.onCloseLeafMenu = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (!this.isLeaf) {
                return;
            }
            this.cancelEvent(event);
            this.closeLeafMenu.emit({
                exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE,
                event: event
            });
        };
        /**
         * @param {?} event
         * @return {?}
         */
        ContextMenuContentComponent.prototype.closeMenu = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event.type === 'click' && event.button === 2) {
                return;
            }
            this.closeAllMenus.emit({ event: event });
        };
        /**
         * @param {?} menuItem
         * @param {?=} event
         * @return {?}
         */
        ContextMenuContentComponent.prototype.onOpenSubMenu = /**
         * @param {?} menuItem
         * @param {?=} event
         * @return {?}
         */
        function (menuItem, event) {
            /** @type {?} */
            var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];
            /** @type {?} */
            var anchorElement = anchorElementRef && anchorElementRef.nativeElement;
            this.openSubMenu.emit({
                anchorElement: anchorElement,
                contextMenu: menuItem.subMenu,
                event: event,
                item: this.item,
                parentContextMenu: this
            });
        };
        /**
         * @param {?} menuItem
         * @param {?} event
         * @return {?}
         */
        ContextMenuContentComponent.prototype.onMenuItemSelect = /**
         * @param {?} menuItem
         * @param {?} event
         * @return {?}
         */
        function (menuItem, event) {
            event.preventDefault();
            event.stopPropagation();
            this.onOpenSubMenu(menuItem, event);
            if (!menuItem.subMenu) {
                menuItem.triggerExecute(this.item, event);
            }
        };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        ContextMenuContentComponent.prototype.cancelEvent = /**
         * @private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (!event) {
                return;
            }
            /** @type {?} */
            var target = event.target;
            if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 ||
                target.isContentEditable) {
                return;
            }
            event.preventDefault();
            event.stopPropagation();
        };
        ContextMenuContentComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'context-menu-content',
                        template: "\n    <div\n      class=\"dropdown open show ngx-contextmenu\"\n      [ngClass]=\"menuClass\"\n      tabindex=\"0\"\n    >\n      <ul\n        #menu\n        class=\"dropdown-menu show\"\n        style=\"position: static; float: none;\"\n        tabindex=\"0\"\n      >\n        <li\n          #li\n          *ngFor=\"let menuItem of menuItems; let i = index\"\n          [class.disabled]=\"!isMenuItemEnabled(menuItem)\"\n          [class.divider]=\"menuItem.divider\"\n          [class.dropdown-divider]=\"useBootstrap4 && menuItem.divider\"\n          [class.active]=\"menuItem.isActive && isMenuItemEnabled(menuItem)\"\n          [attr.role]=\"menuItem.divider ? 'separator' : undefined\"\n        >\n          <a\n            *ngIf=\"!menuItem.divider && !menuItem.passive\"\n            href\n            [class.dropdown-item]=\"useBootstrap4\"\n            [class.active]=\"menuItem.isActive && isMenuItemEnabled(menuItem)\"\n            [class.disabled]=\"useBootstrap4 && !isMenuItemEnabled(menuItem)\"\n            [class.hasSubMenu]=\"!!menuItem.subMenu\"\n            (click)=\"onMenuItemSelect(menuItem, $event)\"\n            (mouseenter)=\"onOpenSubMenu(menuItem, $event)\"\n          >\n            <ng-template\n              [ngTemplateOutlet]=\"menuItem.template\"\n              [ngTemplateOutletContext]=\"{ $implicit: item }\"\n            ></ng-template>\n          </a>\n\n          <span\n            (click)=\"stopEvent($event)\"\n            (contextmenu)=\"stopEvent($event)\"\n            class=\"passive\"\n            *ngIf=\"!menuItem.divider && menuItem.passive\"\n            [class.dropdown-item]=\"useBootstrap4\"\n            [class.disabled]=\"useBootstrap4 && !isMenuItemEnabled(menuItem)\"\n          >\n            <ng-template\n              [ngTemplateOutlet]=\"menuItem.template\"\n              [ngTemplateOutletContext]=\"{ $implicit: item }\"\n            ></ng-template>\n          </span>\n        </li>\n      </ul>\n    </div>\n  ",
                        styles: ["\n      .passive {\n        display: block;\n        padding: 3px 20px;\n        clear: both;\n        font-weight: normal;\n        line-height: @line-height-base;\n        white-space: nowrap;\n      }\n      .hasSubMenu:before {\n        content: '\u25B6';\n        float: right;\n      }\n    "]
                    }] }
        ];
        /** @nocollapse */
        ContextMenuContentComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [CONTEXT_MENU_OPTIONS,] }] }
        ]; };
        ContextMenuContentComponent.propDecorators = {
            menuItems: [{ type: core.Input }],
            item: [{ type: core.Input }],
            event: [{ type: core.Input }],
            parentContextMenu: [{ type: core.Input }],
            menuClass: [{ type: core.Input }],
            overlay: [{ type: core.Input }],
            isLeaf: [{ type: core.Input }],
            execute: [{ type: core.Output }],
            openSubMenu: [{ type: core.Output }],
            closeLeafMenu: [{ type: core.Output }],
            closeAllMenus: [{ type: core.Output }],
            menuElement: [{ type: core.ViewChild, args: ['menu', { static: true },] }],
            menuItemElements: [{ type: core.ViewChildren, args: ['li',] }],
            onKeyEvent: [{ type: core.HostListener, args: ['window:keydown.ArrowDown', ['$event'],] }, { type: core.HostListener, args: ['window:keydown.ArrowUp', ['$event'],] }],
            keyboardOpenSubMenu: [{ type: core.HostListener, args: ['window:keydown.ArrowRight', ['$event'],] }],
            keyboardMenuItemSelect: [{ type: core.HostListener, args: ['window:keydown.Enter', ['$event'],] }, { type: core.HostListener, args: ['window:keydown.Space', ['$event'],] }],
            onCloseLeafMenu: [{ type: core.HostListener, args: ['window:keydown.Escape', ['$event'],] }, { type: core.HostListener, args: ['window:keydown.ArrowLeft', ['$event'],] }],
            closeMenu: [{ type: core.HostListener, args: ['document:click', ['$event'],] }, { type: core.HostListener, args: ['document:contextmenu', ['$event'],] }]
        };
        return ContextMenuContentComponent;
    }());
    if (false) {
        /** @type {?} */
        ContextMenuContentComponent.prototype.menuItems;
        /** @type {?} */
        ContextMenuContentComponent.prototype.item;
        /** @type {?} */
        ContextMenuContentComponent.prototype.event;
        /** @type {?} */
        ContextMenuContentComponent.prototype.parentContextMenu;
        /** @type {?} */
        ContextMenuContentComponent.prototype.menuClass;
        /** @type {?} */
        ContextMenuContentComponent.prototype.overlay;
        /** @type {?} */
        ContextMenuContentComponent.prototype.isLeaf;
        /** @type {?} */
        ContextMenuContentComponent.prototype.execute;
        /** @type {?} */
        ContextMenuContentComponent.prototype.openSubMenu;
        /** @type {?} */
        ContextMenuContentComponent.prototype.closeLeafMenu;
        /** @type {?} */
        ContextMenuContentComponent.prototype.closeAllMenus;
        /** @type {?} */
        ContextMenuContentComponent.prototype.menuElement;
        /** @type {?} */
        ContextMenuContentComponent.prototype.menuItemElements;
        /** @type {?} */
        ContextMenuContentComponent.prototype.autoFocus;
        /** @type {?} */
        ContextMenuContentComponent.prototype.useBootstrap4;
        /**
         * @type {?}
         * @private
         */
        ContextMenuContentComponent.prototype._keyManager;
        /**
         * @type {?}
         * @private
         */
        ContextMenuContentComponent.prototype.subscription;
        /**
         * @type {?}
         * @private
         */
        ContextMenuContentComponent.prototype.changeDetector;
        /**
         * @type {?}
         * @private
         */
        ContextMenuContentComponent.prototype.elementRef;
        /**
         * @type {?}
         * @private
         */
        ContextMenuContentComponent.prototype.options;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function IContextMenuClickEvent() { }
    if (false) {
        /** @type {?|undefined} */
        IContextMenuClickEvent.prototype.anchorElement;
        /** @type {?|undefined} */
        IContextMenuClickEvent.prototype.contextMenu;
        /** @type {?|undefined} */
        IContextMenuClickEvent.prototype.event;
        /** @type {?|undefined} */
        IContextMenuClickEvent.prototype.parentContextMenu;
        /** @type {?} */
        IContextMenuClickEvent.prototype.item;
        /** @type {?|undefined} */
        IContextMenuClickEvent.prototype.activeMenuItemIndex;
    }
    /**
     * @record
     */
    function IContextMenuContext() { }
    if (false) {
        /** @type {?} */
        IContextMenuContext.prototype.menuItems;
        /** @type {?} */
        IContextMenuContext.prototype.menuClass;
    }
    /**
     * @record
     */
    function CloseLeafMenuEvent() { }
    if (false) {
        /** @type {?|undefined} */
        CloseLeafMenuEvent.prototype.exceptRootMenu;
        /** @type {?|undefined} */
        CloseLeafMenuEvent.prototype.event;
    }
    /**
     * @record
     */
    function OverlayRefWithContextMenu() { }
    if (false) {
        /** @type {?|undefined} */
        OverlayRefWithContextMenu.prototype.contextMenu;
    }
    /**
     * @record
     */
    function CancelContextMenuEvent() { }
    if (false) {
        /** @type {?} */
        CancelContextMenuEvent.prototype.eventType;
        /** @type {?|undefined} */
        CancelContextMenuEvent.prototype.event;
    }
    /**
     * @record
     */
    function ExecuteContextMenuEvent() { }
    if (false) {
        /** @type {?} */
        ExecuteContextMenuEvent.prototype.eventType;
        /** @type {?|undefined} */
        ExecuteContextMenuEvent.prototype.event;
        /** @type {?} */
        ExecuteContextMenuEvent.prototype.item;
        /** @type {?} */
        ExecuteContextMenuEvent.prototype.menuItem;
    }
    var ContextMenuService = /** @class */ (function () {
        function ContextMenuService(overlay, scrollStrategy) {
            this.overlay = overlay;
            this.scrollStrategy = scrollStrategy;
            this.isDestroyingLeafMenu = false;
            this.show = new rxjs.Subject();
            this.triggerClose = new rxjs.Subject();
            this.close = new rxjs.Subject();
            this.overlays = [];
            this.fakeElement = {
                getBoundingClientRect: (/**
                 * @return {?}
                 */
                function () { return ({
                    bottom: 0,
                    height: 0,
                    left: 0,
                    right: 0,
                    top: 0,
                    width: 0,
                }); })
            };
        }
        /**
         * @param {?} context
         * @return {?}
         */
        ContextMenuService.prototype.openContextMenu = /**
         * @param {?} context
         * @return {?}
         */
        function (context) {
            var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;
            if (!parentContextMenu) {
                /** @type {?} */
                var mouseEvent_1 = (/** @type {?} */ (event));
                this.fakeElement.getBoundingClientRect = (/**
                 * @return {?}
                 */
                function () { return ({
                    bottom: mouseEvent_1.clientY,
                    height: 0,
                    left: mouseEvent_1.clientX,
                    right: mouseEvent_1.clientX,
                    top: mouseEvent_1.clientY,
                    width: 0,
                }); });
                this.closeAllContextMenus({ eventType: 'cancel', event: event });
                /** @type {?} */
                var positionStrategy = this.overlay.position().connectedTo(new core.ElementRef(anchorElement || this.fakeElement), { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })
                    .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
                    .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
                    .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
                    .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })
                    .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });
                this.overlays = [this.overlay.create({
                        positionStrategy: positionStrategy,
                        panelClass: 'ngx-contextmenu',
                        scrollStrategy: this.scrollStrategy.close(),
                    })];
                this.attachContextMenu(this.overlays[0], context);
            }
            else {
                /** @type {?} */
                var positionStrategy = this.overlay.position().connectedTo(new core.ElementRef(event ? event.target : anchorElement), { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
                    .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
                    .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })
                    .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });
                /** @type {?} */
                var newOverlay = this.overlay.create({
                    positionStrategy: positionStrategy,
                    panelClass: 'ngx-contextmenu',
                    scrollStrategy: this.scrollStrategy.close(),
                });
                this.destroySubMenus(parentContextMenu);
                this.overlays = this.overlays.concat(newOverlay);
                this.attachContextMenu(newOverlay, context);
            }
        };
        /**
         * @param {?} overlay
         * @param {?} context
         * @return {?}
         */
        ContextMenuService.prototype.attachContextMenu = /**
         * @param {?} overlay
         * @param {?} context
         * @return {?}
         */
        function (overlay, context) {
            var _this = this;
            var event = context.event, item = context.item, menuItems = context.menuItems, menuClass = context.menuClass;
            /** @type {?} */
            var contextMenuContent = overlay.attach(new portal.ComponentPortal(ContextMenuContentComponent));
            contextMenuContent.instance.event = event;
            contextMenuContent.instance.item = item;
            contextMenuContent.instance.menuItems = menuItems;
            contextMenuContent.instance.overlay = overlay;
            contextMenuContent.instance.isLeaf = true;
            contextMenuContent.instance.menuClass = menuClass;
            ((/** @type {?} */ (overlay))).contextMenu = contextMenuContent.instance;
            /** @type {?} */
            var subscriptions = new rxjs.Subscription();
            subscriptions.add(contextMenuContent.instance.execute.asObservable()
                .subscribe((/**
             * @param {?} executeEvent
             * @return {?}
             */
            function (executeEvent) { return _this.closeAllContextMenus(__assign({ eventType: 'execute' }, executeEvent)); })));
            subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()
                .subscribe((/**
             * @param {?} closeAllEvent
             * @return {?}
             */
            function (closeAllEvent) { return _this.closeAllContextMenus(__assign({ eventType: 'cancel' }, closeAllEvent)); })));
            subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()
                .subscribe((/**
             * @param {?} closeLeafMenuEvent
             * @return {?}
             */
            function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); })));
            subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()
                .subscribe((/**
             * @param {?} subMenuEvent
             * @return {?}
             */
            function (subMenuEvent) {
                _this.destroySubMenus(contextMenuContent.instance);
                if (!subMenuEvent.contextMenu) {
                    contextMenuContent.instance.isLeaf = true;
                    return;
                }
                contextMenuContent.instance.isLeaf = false;
                _this.show.next(subMenuEvent);
            })));
            contextMenuContent.onDestroy((/**
             * @return {?}
             */
            function () {
                menuItems.forEach((/**
                 * @param {?} menuItem
                 * @return {?}
                 */
                function (menuItem) { return menuItem.isActive = false; }));
                subscriptions.unsubscribe();
            }));
            contextMenuContent.changeDetectorRef.detectChanges();
        };
        /**
         * @param {?} closeEvent
         * @return {?}
         */
        ContextMenuService.prototype.closeAllContextMenus = /**
         * @param {?} closeEvent
         * @return {?}
         */
        function (closeEvent) {
            if (this.overlays) {
                this.close.next(closeEvent);
                this.overlays.forEach((/**
                 * @param {?} overlay
                 * @param {?} index
                 * @return {?}
                 */
                function (overlay, index) {
                    overlay.detach();
                    overlay.dispose();
                }));
            }
            this.overlays = [];
        };
        /**
         * @return {?}
         */
        ContextMenuService.prototype.getLastAttachedOverlay = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var overlay = this.overlays[this.overlays.length - 1];
            while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {
                overlay.detach();
                overlay.dispose();
                this.overlays = this.overlays.slice(0, -1);
                overlay = this.overlays[this.overlays.length - 1];
            }
            return overlay;
        };
        /**
         * @param {?=} __0
         * @return {?}
         */
        ContextMenuService.prototype.destroyLeafMenu = /**
         * @param {?=} __0
         * @return {?}
         */
        function (_a) {
            var _this = this;
            var _b = _a === void 0 ? {} : _a, exceptRootMenu = _b.exceptRootMenu, event = _b.event;
            if (this.isDestroyingLeafMenu) {
                return;
            }
            this.isDestroyingLeafMenu = true;
            setTimeout((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var overlay = _this.getLastAttachedOverlay();
                if (_this.overlays.length > 1 && overlay) {
                    overlay.detach();
                    overlay.dispose();
                }
                if (!exceptRootMenu && _this.overlays.length > 0 && overlay) {
                    _this.close.next({ eventType: 'cancel', event: event });
                    overlay.detach();
                    overlay.dispose();
                }
                /** @type {?} */
                var newLeaf = _this.getLastAttachedOverlay();
                if (newLeaf) {
                    newLeaf.contextMenu.isLeaf = true;
                }
                _this.isDestroyingLeafMenu = false;
            }));
        };
        /**
         * @param {?} contextMenu
         * @return {?}
         */
        ContextMenuService.prototype.destroySubMenus = /**
         * @param {?} contextMenu
         * @return {?}
         */
        function (contextMenu) {
            /** @type {?} */
            var overlay = contextMenu.overlay;
            /** @type {?} */
            var index = this.overlays.indexOf(overlay);
            this.overlays.slice(index + 1).forEach((/**
             * @param {?} subMenuOverlay
             * @return {?}
             */
            function (subMenuOverlay) {
                subMenuOverlay.detach();
                subMenuOverlay.dispose();
            }));
        };
        /**
         * @param {?} contextMenuContent
         * @return {?}
         */
        ContextMenuService.prototype.isLeafMenu = /**
         * @param {?} contextMenuContent
         * @return {?}
         */
        function (contextMenuContent) {
            /** @type {?} */
            var overlay = this.getLastAttachedOverlay();
            return contextMenuContent.overlay === overlay;
        };
        ContextMenuService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        ContextMenuService.ctorParameters = function () { return [
            { type: overlay.Overlay },
            { type: overlay.ScrollStrategyOptions }
        ]; };
        return ContextMenuService;
    }());
    if (false) {
        /** @type {?} */
        ContextMenuService.prototype.isDestroyingLeafMenu;
        /** @type {?} */
        ContextMenuService.prototype.show;
        /** @type {?} */
        ContextMenuService.prototype.triggerClose;
        /** @type {?} */
        ContextMenuService.prototype.close;
        /**
         * @type {?}
         * @private
         */
        ContextMenuService.prototype.contextMenuContent;
        /**
         * @type {?}
         * @private
         */
        ContextMenuService.prototype.overlays;
        /**
         * @type {?}
         * @private
         */
        ContextMenuService.prototype.fakeElement;
        /**
         * @type {?}
         * @private
         */
        ContextMenuService.prototype.overlay;
        /**
         * @type {?}
         * @private
         */
        ContextMenuService.prototype.scrollStrategy;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function ILinkConfig$1() { }
    if (false) {
        /** @type {?} */
        ILinkConfig$1.prototype.click;
        /** @type {?|undefined} */
        ILinkConfig$1.prototype.enabled;
        /** @type {?} */
        ILinkConfig$1.prototype.html;
    }
    /**
     * @record
     */
    function MouseLocation() { }
    if (false) {
        /** @type {?|undefined} */
        MouseLocation.prototype.left;
        /** @type {?|undefined} */
        MouseLocation.prototype.marginLeft;
        /** @type {?|undefined} */
        MouseLocation.prototype.marginTop;
        /** @type {?|undefined} */
        MouseLocation.prototype.top;
    }
    var ContextMenuComponent = /** @class */ (function () {
        function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {
            var _this = this;
            this._contextMenuService = _contextMenuService;
            this.changeDetector = changeDetector;
            this.elementRef = elementRef;
            this.options = options;
            this.menuClass = "";
            this.autoFocus = false;
            this.useBootstrap4 = false;
            this.disabled = false;
            this.close = new core.EventEmitter();
            this.open = new core.EventEmitter();
            this.visibleMenuItems = [];
            this.links = [];
            this.subscription = new rxjs.Subscription();
            if (options) {
                this.autoFocus = options.autoFocus;
                this.useBootstrap4 = options.useBootstrap4;
            }
            this.subscription.add(_contextMenuService.show.subscribe((/**
             * @param {?} menuEvent
             * @return {?}
             */
            function (menuEvent) {
                _this.onMenuEvent(menuEvent);
            })));
        }
        /**
         * @return {?}
         */
        ContextMenuComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.subscription.unsubscribe();
        };
        /**
         * @param {?} menuEvent
         * @return {?}
         */
        ContextMenuComponent.prototype.onMenuEvent = /**
         * @param {?} menuEvent
         * @return {?}
         */
        function (menuEvent) {
            var _this = this;
            if (this.disabled) {
                return;
            }
            var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;
            if (contextMenu && contextMenu !== this) {
                return;
            }
            this.event = event;
            this.item = item;
            this.setVisibleMenuItems();
            this._contextMenuService.openContextMenu(__assign({}, menuEvent, { menuItems: this.visibleMenuItems, menuClass: this.menuClass }));
            this._contextMenuService.close.asObservable().pipe(operators.first()).subscribe((/**
             * @param {?} closeEvent
             * @return {?}
             */
            function (closeEvent) { return _this.close.emit(closeEvent); }));
            this.open.next(menuEvent);
        };
        /**
         * @param {?} menuItem
         * @return {?}
         */
        ContextMenuComponent.prototype.isMenuItemVisible = /**
         * @param {?} menuItem
         * @return {?}
         */
        function (menuItem) {
            return this.evaluateIfFunction(menuItem.visible);
        };
        /**
         * @return {?}
         */
        ContextMenuComponent.prototype.setVisibleMenuItems = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.visibleMenuItems = this.menuItems.filter((/**
             * @param {?} menuItem
             * @return {?}
             */
            function (menuItem) { return _this.isMenuItemVisible(menuItem); }));
        };
        /**
         * @param {?} value
         * @return {?}
         */
        ContextMenuComponent.prototype.evaluateIfFunction = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value instanceof Function) {
                return value(this.item);
            }
            return value;
        };
        ContextMenuComponent.decorators = [
            { type: core.Component, args: [{
                        encapsulation: core.ViewEncapsulation.None,
                        selector: 'context-menu',
                        template: " ",
                        styles: ["\n    .cdk-overlay-container {\n      position: fixed;\n      z-index: 1000;\n      pointer-events: none;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n    }\n    .ngx-contextmenu.cdk-overlay-pane {\n      position: absolute;\n      pointer-events: auto;\n      box-sizing: border-box;\n    }\n  "]
                    }] }
        ];
        /** @nocollapse */
        ContextMenuComponent.ctorParameters = function () { return [
            { type: ContextMenuService },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [CONTEXT_MENU_OPTIONS,] }] }
        ]; };
        ContextMenuComponent.propDecorators = {
            menuClass: [{ type: core.Input }],
            autoFocus: [{ type: core.Input }],
            useBootstrap4: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            close: [{ type: core.Output }],
            open: [{ type: core.Output }],
            menuItems: [{ type: core.ContentChildren, args: [ContextMenuItemDirective,] }],
            menuElement: [{ type: core.ViewChild, args: ['menu', { static: false },] }]
        };
        return ContextMenuComponent;
    }());
    if (false) {
        /** @type {?} */
        ContextMenuComponent.prototype.menuClass;
        /** @type {?} */
        ContextMenuComponent.prototype.autoFocus;
        /** @type {?} */
        ContextMenuComponent.prototype.useBootstrap4;
        /** @type {?} */
        ContextMenuComponent.prototype.disabled;
        /** @type {?} */
        ContextMenuComponent.prototype.close;
        /** @type {?} */
        ContextMenuComponent.prototype.open;
        /** @type {?} */
        ContextMenuComponent.prototype.menuItems;
        /** @type {?} */
        ContextMenuComponent.prototype.menuElement;
        /** @type {?} */
        ContextMenuComponent.prototype.visibleMenuItems;
        /** @type {?} */
        ContextMenuComponent.prototype.links;
        /** @type {?} */
        ContextMenuComponent.prototype.item;
        /** @type {?} */
        ContextMenuComponent.prototype.event;
        /**
         * @type {?}
         * @private
         */
        ContextMenuComponent.prototype.subscription;
        /**
         * @type {?}
         * @private
         */
        ContextMenuComponent.prototype._contextMenuService;
        /**
         * @type {?}
         * @private
         */
        ContextMenuComponent.prototype.changeDetector;
        /**
         * @type {?}
         * @private
         */
        ContextMenuComponent.prototype.elementRef;
        /**
         * @type {?}
         * @private
         */
        ContextMenuComponent.prototype.options;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ContextMenuAttachDirective = /** @class */ (function () {
        function ContextMenuAttachDirective(contextMenuService) {
            this.contextMenuService = contextMenuService;
        }
        /**
         * @param {?} event
         * @return {?}
         */
        ContextMenuAttachDirective.prototype.onContextMenu = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (!this.contextMenu.disabled) {
                this.contextMenuService.show.next({
                    contextMenu: this.contextMenu,
                    event: event,
                    item: this.contextMenuSubject,
                });
                event.preventDefault();
                event.stopPropagation();
            }
        };
        ContextMenuAttachDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[contextMenu]',
                    },] }
        ];
        /** @nocollapse */
        ContextMenuAttachDirective.ctorParameters = function () { return [
            { type: ContextMenuService }
        ]; };
        ContextMenuAttachDirective.propDecorators = {
            contextMenuSubject: [{ type: core.Input }],
            contextMenu: [{ type: core.Input }],
            onContextMenu: [{ type: core.HostListener, args: ['contextmenu', ['$event'],] }]
        };
        return ContextMenuAttachDirective;
    }());
    if (false) {
        /** @type {?} */
        ContextMenuAttachDirective.prototype.contextMenuSubject;
        /** @type {?} */
        ContextMenuAttachDirective.prototype.contextMenu;
        /**
         * @type {?}
         * @private
         */
        ContextMenuAttachDirective.prototype.contextMenuService;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ContextMenuModule = /** @class */ (function () {
        function ContextMenuModule() {
        }
        /**
         * @param {?=} options
         * @return {?}
         */
        ContextMenuModule.forRoot = /**
         * @param {?=} options
         * @return {?}
         */
        function (options) {
            return {
                ngModule: ContextMenuModule,
                providers: [
                    ContextMenuService,
                    {
                        provide: CONTEXT_MENU_OPTIONS,
                        useValue: options,
                    },
                    { provide: overlay.OverlayContainer, useClass: overlay.FullscreenOverlayContainer },
                ],
            };
        };
        ContextMenuModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ContextMenuAttachDirective,
                            ContextMenuComponent,
                            ContextMenuContentComponent,
                            ContextMenuItemDirective,
                        ],
                        entryComponents: [
                            ContextMenuContentComponent,
                        ],
                        exports: [
                            ContextMenuAttachDirective,
                            ContextMenuComponent,
                            ContextMenuItemDirective,
                        ],
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                        ],
                    },] }
        ];
        return ContextMenuModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function IContextMenuOptions() { }
    if (false) {
        /** @type {?|undefined} */
        IContextMenuOptions.prototype.useBootstrap4;
        /** @type {?|undefined} */
        IContextMenuOptions.prototype.autoFocus;
    }

    exports.ContextMenuComponent = ContextMenuComponent;
    exports.ContextMenuModule = ContextMenuModule;
    exports.ContextMenuService = ContextMenuService;
    exports.ɵa = ContextMenuAttachDirective;
    exports.ɵb = ContextMenuItemDirective;
    exports.ɵc = CONTEXT_MENU_OPTIONS;
    exports.ɵd = ContextMenuContentComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-contextmenu.umd.js.map
