import { Overlay, ScrollStrategyOptions, OverlayContainer, FullscreenOverlayContainer, OverlayModule } from '@angular/cdk/overlay';
import { CommonModule } from '@angular/common';
import { EventEmitter, Directive, TemplateRef, ElementRef, Input, Output, InjectionToken, QueryList, Component, ChangeDetectorRef, Optional, Inject, ViewChild, ViewChildren, HostListener, Injectable, ViewEncapsulation, ContentChildren, NgModule } from '@angular/core';
import { __assign } from 'tslib';
import { Subscription, Subject } from 'rxjs';
import { first } from 'rxjs/operators';
import { ComponentPortal } from '@angular/cdk/portal';
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContextMenuItemDirective = /** @class */ (function () {
    function ContextMenuItemDirective(template, elementRef) {
        this.template = template;
        this.elementRef = elementRef;
        this.divider = false;
        this.enabled = true;
        this.passive = false;
        this.visible = true;
        this.execute = new EventEmitter();
        this.isActive = false;
    }
    Object.defineProperty(ContextMenuItemDirective.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.passive ||
                this.divider ||
                !this.evaluateIfFunction(this.enabled, this.currentItem);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @param {?} item
     * @return {?}
     */
    ContextMenuItemDirective.prototype.evaluateIfFunction = /**
     * @param {?} value
     * @param {?} item
     * @return {?}
     */
    function (value, item) {
        if (value instanceof Function) {
            return value(item);
        }
        return value;
    };
    /**
     * @return {?}
     */
    ContextMenuItemDirective.prototype.setActiveStyles = /**
     * @return {?}
     */
    function () {
        this.isActive = true;
    };
    /**
     * @return {?}
     */
    ContextMenuItemDirective.prototype.setInactiveStyles = /**
     * @return {?}
     */
    function () {
        this.isActive = false;
    };
    /**
     * @param {?} item
     * @param {?=} $event
     * @return {?}
     */
    ContextMenuItemDirective.prototype.triggerExecute = /**
     * @param {?} item
     * @param {?=} $event
     * @return {?}
     */
    function (item, $event) {
        if (!this.evaluateIfFunction(this.enabled, item)) {
            return;
        }
        this.execute.emit({ event: $event, item: item });
    };
    ContextMenuItemDirective.decorators = [
        { type: Directive, args: [{
                    /* tslint:disable:directive-selector-type */
                    selector: '[contextMenuItem]',
                },] }
    ];
    /** @nocollapse */
    ContextMenuItemDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ElementRef }
    ]; };
    ContextMenuItemDirective.propDecorators = {
        subMenu: [{ type: Input }],
        divider: [{ type: Input }],
        enabled: [{ type: Input }],
        passive: [{ type: Input }],
        visible: [{ type: Input }],
        execute: [{ type: Output }]
    };
    return ContextMenuItemDirective;
}());
if (false) {
    /** @type {?} */
    ContextMenuItemDirective.prototype.subMenu;
    /** @type {?} */
    ContextMenuItemDirective.prototype.divider;
    /** @type {?} */
    ContextMenuItemDirective.prototype.enabled;
    /** @type {?} */
    ContextMenuItemDirective.prototype.passive;
    /** @type {?} */
    ContextMenuItemDirective.prototype.visible;
    /** @type {?} */
    ContextMenuItemDirective.prototype.execute;
    /** @type {?} */
    ContextMenuItemDirective.prototype.currentItem;
    /** @type {?} */
    ContextMenuItemDirective.prototype.isActive;
    /** @type {?} */
    ContextMenuItemDirective.prototype.template;
    /** @type {?} */
    ContextMenuItemDirective.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var CONTEXT_MENU_OPTIONS = new InjectionToken('CONTEXT_MENU_OPTIONS');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ILinkConfig() { }
if (false) {
    /** @type {?} */
    ILinkConfig.prototype.click;
    /** @type {?|undefined} */
    ILinkConfig.prototype.enabled;
    /** @type {?} */
    ILinkConfig.prototype.html;
}
/** @type {?} */
var ARROW_LEFT_KEYCODE = 37;
var ContextMenuContentComponent = /** @class */ (function () {
    function ContextMenuContentComponent(changeDetector, elementRef, options) {
        this.changeDetector = changeDetector;
        this.elementRef = elementRef;
        this.options = options;
        this.menuItems = [];
        this.isLeaf = false;
        this.execute = new EventEmitter();
        this.openSubMenu = new EventEmitter();
        this.closeLeafMenu = new EventEmitter();
        this.closeAllMenus = new EventEmitter();
        this.autoFocus = false;
        this.useBootstrap4 = false;
        this.subscription = new Subscription();
        if (options) {
            this.autoFocus = options.autoFocus;
            this.useBootstrap4 = options.useBootstrap4;
        }
    }
    /**
     * @return {?}
     */
    ContextMenuContentComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.menuItems.forEach((/**
         * @param {?} menuItem
         * @return {?}
         */
        function (menuItem) {
            menuItem.currentItem = _this.item;
            _this.subscription.add(menuItem.execute.subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                return _this.execute.emit(__assign({}, event, { menuItem: menuItem }));
            })));
        }));
        /** @type {?} */
        var queryList = new QueryList();
        queryList.reset(this.menuItems);
        this._keyManager = new ActiveDescendantKeyManager(queryList).withWrap();
    };
    /**
     * @return {?}
     */
    ContextMenuContentComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.autoFocus) {
            setTimeout((/**
             * @return {?}
             */
            function () { return _this.focus(); }));
        }
        this.overlay.updatePosition();
    };
    /**
     * @return {?}
     */
    ContextMenuContentComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    /**
     * @return {?}
     */
    ContextMenuContentComponent.prototype.focus = /**
     * @return {?}
     */
    function () {
        if (this.autoFocus) {
            this.menuElement.nativeElement.focus();
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ContextMenuContentComponent.prototype.stopEvent = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        $event.stopPropagation();
    };
    /**
     * @param {?} menuItem
     * @return {?}
     */
    ContextMenuContentComponent.prototype.isMenuItemEnabled = /**
     * @param {?} menuItem
     * @return {?}
     */
    function (menuItem) {
        return this.evaluateIfFunction(menuItem && menuItem.enabled);
    };
    /**
     * @param {?} menuItem
     * @return {?}
     */
    ContextMenuContentComponent.prototype.isMenuItemVisible = /**
     * @param {?} menuItem
     * @return {?}
     */
    function (menuItem) {
        return this.evaluateIfFunction(menuItem && menuItem.visible);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ContextMenuContentComponent.prototype.evaluateIfFunction = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value instanceof Function) {
            return value(this.item);
        }
        return value;
    };
    /**
     * @param {?} link
     * @return {?}
     */
    ContextMenuContentComponent.prototype.isDisabled = /**
     * @param {?} link
     * @return {?}
     */
    function (link) {
        return link.enabled && !link.enabled(this.item);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ContextMenuContentComponent.prototype.onKeyEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.isLeaf) {
            return;
        }
        this._keyManager.onKeydown(event);
    };
    /**
     * @param {?=} event
     * @return {?}
     */
    ContextMenuContentComponent.prototype.keyboardOpenSubMenu = /**
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        if (!this.isLeaf) {
            return;
        }
        this.cancelEvent(event);
        /** @type {?} */
        var menuItem = this.menuItems[this._keyManager.activeItemIndex];
        if (menuItem) {
            this.onOpenSubMenu(menuItem);
        }
    };
    /**
     * @param {?=} event
     * @return {?}
     */
    ContextMenuContentComponent.prototype.keyboardMenuItemSelect = /**
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        if (!this.isLeaf) {
            return;
        }
        this.cancelEvent(event);
        /** @type {?} */
        var menuItem = this.menuItems[this._keyManager.activeItemIndex];
        if (menuItem) {
            this.onMenuItemSelect(menuItem, event);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ContextMenuContentComponent.prototype.onCloseLeafMenu = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.isLeaf) {
            return;
        }
        this.cancelEvent(event);
        this.closeLeafMenu.emit({
            exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE,
            event: event
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ContextMenuContentComponent.prototype.closeMenu = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.type === 'click' && event.button === 2) {
            return;
        }
        this.closeAllMenus.emit({ event: event });
    };
    /**
     * @param {?} menuItem
     * @param {?=} event
     * @return {?}
     */
    ContextMenuContentComponent.prototype.onOpenSubMenu = /**
     * @param {?} menuItem
     * @param {?=} event
     * @return {?}
     */
    function (menuItem, event) {
        /** @type {?} */
        var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];
        /** @type {?} */
        var anchorElement = anchorElementRef && anchorElementRef.nativeElement;
        this.openSubMenu.emit({
            anchorElement: anchorElement,
            contextMenu: menuItem.subMenu,
            event: event,
            item: this.item,
            parentContextMenu: this
        });
    };
    /**
     * @param {?} menuItem
     * @param {?} event
     * @return {?}
     */
    ContextMenuContentComponent.prototype.onMenuItemSelect = /**
     * @param {?} menuItem
     * @param {?} event
     * @return {?}
     */
    function (menuItem, event) {
        event.preventDefault();
        event.stopPropagation();
        this.onOpenSubMenu(menuItem, event);
        if (!menuItem.subMenu) {
            menuItem.triggerExecute(this.item, event);
        }
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ContextMenuContentComponent.prototype.cancelEvent = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!event) {
            return;
        }
        /** @type {?} */
        var target = event.target;
        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 ||
            target.isContentEditable) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
    };
    ContextMenuContentComponent.decorators = [
        { type: Component, args: [{
                    selector: 'context-menu-content',
                    template: "\n    <div\n      class=\"dropdown open show ngx-contextmenu\"\n      [ngClass]=\"menuClass\"\n      tabindex=\"0\"\n    >\n      <ul\n        #menu\n        class=\"dropdown-menu show\"\n        style=\"position: static; float: none;\"\n        tabindex=\"0\"\n      >\n        <li\n          #li\n          *ngFor=\"let menuItem of menuItems; let i = index\"\n          [class.disabled]=\"!isMenuItemEnabled(menuItem)\"\n          [class.divider]=\"menuItem.divider\"\n          [class.dropdown-divider]=\"useBootstrap4 && menuItem.divider\"\n          [class.active]=\"menuItem.isActive && isMenuItemEnabled(menuItem)\"\n          [attr.role]=\"menuItem.divider ? 'separator' : undefined\"\n        >\n          <a\n            *ngIf=\"!menuItem.divider && !menuItem.passive\"\n            href\n            [class.dropdown-item]=\"useBootstrap4\"\n            [class.active]=\"menuItem.isActive && isMenuItemEnabled(menuItem)\"\n            [class.disabled]=\"useBootstrap4 && !isMenuItemEnabled(menuItem)\"\n            [class.hasSubMenu]=\"!!menuItem.subMenu\"\n            (click)=\"onMenuItemSelect(menuItem, $event)\"\n            (mouseenter)=\"onOpenSubMenu(menuItem, $event)\"\n          >\n            <ng-template\n              [ngTemplateOutlet]=\"menuItem.template\"\n              [ngTemplateOutletContext]=\"{ $implicit: item }\"\n            ></ng-template>\n          </a>\n\n          <span\n            (click)=\"stopEvent($event)\"\n            (contextmenu)=\"stopEvent($event)\"\n            class=\"passive\"\n            *ngIf=\"!menuItem.divider && menuItem.passive\"\n            [class.dropdown-item]=\"useBootstrap4\"\n            [class.disabled]=\"useBootstrap4 && !isMenuItemEnabled(menuItem)\"\n          >\n            <ng-template\n              [ngTemplateOutlet]=\"menuItem.template\"\n              [ngTemplateOutletContext]=\"{ $implicit: item }\"\n            ></ng-template>\n          </span>\n        </li>\n      </ul>\n    </div>\n  ",
                    styles: ["\n      .passive {\n        display: block;\n        padding: 3px 20px;\n        clear: both;\n        font-weight: normal;\n        line-height: @line-height-base;\n        white-space: nowrap;\n      }\n      .hasSubMenu:before {\n        content: '\u25B6';\n        float: right;\n      }\n    "]
                }] }
    ];
    /** @nocollapse */
    ContextMenuContentComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] }] }
    ]; };
    ContextMenuContentComponent.propDecorators = {
        menuItems: [{ type: Input }],
        item: [{ type: Input }],
        event: [{ type: Input }],
        parentContextMenu: [{ type: Input }],
        menuClass: [{ type: Input }],
        overlay: [{ type: Input }],
        isLeaf: [{ type: Input }],
        execute: [{ type: Output }],
        openSubMenu: [{ type: Output }],
        closeLeafMenu: [{ type: Output }],
        closeAllMenus: [{ type: Output }],
        menuElement: [{ type: ViewChild, args: ['menu', { static: true },] }],
        menuItemElements: [{ type: ViewChildren, args: ['li',] }],
        onKeyEvent: [{ type: HostListener, args: ['window:keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowUp', ['$event'],] }],
        keyboardOpenSubMenu: [{ type: HostListener, args: ['window:keydown.ArrowRight', ['$event'],] }],
        keyboardMenuItemSelect: [{ type: HostListener, args: ['window:keydown.Enter', ['$event'],] }, { type: HostListener, args: ['window:keydown.Space', ['$event'],] }],
        onCloseLeafMenu: [{ type: HostListener, args: ['window:keydown.Escape', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowLeft', ['$event'],] }],
        closeMenu: [{ type: HostListener, args: ['document:click', ['$event'],] }, { type: HostListener, args: ['document:contextmenu', ['$event'],] }]
    };
    return ContextMenuContentComponent;
}());
if (false) {
    /** @type {?} */
    ContextMenuContentComponent.prototype.menuItems;
    /** @type {?} */
    ContextMenuContentComponent.prototype.item;
    /** @type {?} */
    ContextMenuContentComponent.prototype.event;
    /** @type {?} */
    ContextMenuContentComponent.prototype.parentContextMenu;
    /** @type {?} */
    ContextMenuContentComponent.prototype.menuClass;
    /** @type {?} */
    ContextMenuContentComponent.prototype.overlay;
    /** @type {?} */
    ContextMenuContentComponent.prototype.isLeaf;
    /** @type {?} */
    ContextMenuContentComponent.prototype.execute;
    /** @type {?} */
    ContextMenuContentComponent.prototype.openSubMenu;
    /** @type {?} */
    ContextMenuContentComponent.prototype.closeLeafMenu;
    /** @type {?} */
    ContextMenuContentComponent.prototype.closeAllMenus;
    /** @type {?} */
    ContextMenuContentComponent.prototype.menuElement;
    /** @type {?} */
    ContextMenuContentComponent.prototype.menuItemElements;
    /** @type {?} */
    ContextMenuContentComponent.prototype.autoFocus;
    /** @type {?} */
    ContextMenuContentComponent.prototype.useBootstrap4;
    /**
     * @type {?}
     * @private
     */
    ContextMenuContentComponent.prototype._keyManager;
    /**
     * @type {?}
     * @private
     */
    ContextMenuContentComponent.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    ContextMenuContentComponent.prototype.changeDetector;
    /**
     * @type {?}
     * @private
     */
    ContextMenuContentComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    ContextMenuContentComponent.prototype.options;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function IContextMenuClickEvent() { }
if (false) {
    /** @type {?|undefined} */
    IContextMenuClickEvent.prototype.anchorElement;
    /** @type {?|undefined} */
    IContextMenuClickEvent.prototype.contextMenu;
    /** @type {?|undefined} */
    IContextMenuClickEvent.prototype.event;
    /** @type {?|undefined} */
    IContextMenuClickEvent.prototype.parentContextMenu;
    /** @type {?} */
    IContextMenuClickEvent.prototype.item;
    /** @type {?|undefined} */
    IContextMenuClickEvent.prototype.activeMenuItemIndex;
}
/**
 * @record
 */
function IContextMenuContext() { }
if (false) {
    /** @type {?} */
    IContextMenuContext.prototype.menuItems;
    /** @type {?} */
    IContextMenuContext.prototype.menuClass;
}
/**
 * @record
 */
function CloseLeafMenuEvent() { }
if (false) {
    /** @type {?|undefined} */
    CloseLeafMenuEvent.prototype.exceptRootMenu;
    /** @type {?|undefined} */
    CloseLeafMenuEvent.prototype.event;
}
/**
 * @record
 */
function OverlayRefWithContextMenu() { }
if (false) {
    /** @type {?|undefined} */
    OverlayRefWithContextMenu.prototype.contextMenu;
}
/**
 * @record
 */
function CancelContextMenuEvent() { }
if (false) {
    /** @type {?} */
    CancelContextMenuEvent.prototype.eventType;
    /** @type {?|undefined} */
    CancelContextMenuEvent.prototype.event;
}
/**
 * @record
 */
function ExecuteContextMenuEvent() { }
if (false) {
    /** @type {?} */
    ExecuteContextMenuEvent.prototype.eventType;
    /** @type {?|undefined} */
    ExecuteContextMenuEvent.prototype.event;
    /** @type {?} */
    ExecuteContextMenuEvent.prototype.item;
    /** @type {?} */
    ExecuteContextMenuEvent.prototype.menuItem;
}
var ContextMenuService = /** @class */ (function () {
    function ContextMenuService(overlay, scrollStrategy) {
        this.overlay = overlay;
        this.scrollStrategy = scrollStrategy;
        this.isDestroyingLeafMenu = false;
        this.show = new Subject();
        this.triggerClose = new Subject();
        this.close = new Subject();
        this.overlays = [];
        this.fakeElement = {
            getBoundingClientRect: (/**
             * @return {?}
             */
            function () { return ({
                bottom: 0,
                height: 0,
                left: 0,
                right: 0,
                top: 0,
                width: 0,
            }); })
        };
    }
    /**
     * @param {?} context
     * @return {?}
     */
    ContextMenuService.prototype.openContextMenu = /**
     * @param {?} context
     * @return {?}
     */
    function (context) {
        var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;
        if (!parentContextMenu) {
            /** @type {?} */
            var mouseEvent_1 = (/** @type {?} */ (event));
            this.fakeElement.getBoundingClientRect = (/**
             * @return {?}
             */
            function () { return ({
                bottom: mouseEvent_1.clientY,
                height: 0,
                left: mouseEvent_1.clientX,
                right: mouseEvent_1.clientX,
                top: mouseEvent_1.clientY,
                width: 0,
            }); });
            this.closeAllContextMenus({ eventType: 'cancel', event: event });
            /** @type {?} */
            var positionStrategy = this.overlay.position().connectedTo(new ElementRef(anchorElement || this.fakeElement), { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })
                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
                .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
                .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })
                .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });
            this.overlays = [this.overlay.create({
                    positionStrategy: positionStrategy,
                    panelClass: 'ngx-contextmenu',
                    scrollStrategy: this.scrollStrategy.close(),
                })];
            this.attachContextMenu(this.overlays[0], context);
        }
        else {
            /** @type {?} */
            var positionStrategy = this.overlay.position().connectedTo(new ElementRef(event ? event.target : anchorElement), { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
                .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })
                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });
            /** @type {?} */
            var newOverlay = this.overlay.create({
                positionStrategy: positionStrategy,
                panelClass: 'ngx-contextmenu',
                scrollStrategy: this.scrollStrategy.close(),
            });
            this.destroySubMenus(parentContextMenu);
            this.overlays = this.overlays.concat(newOverlay);
            this.attachContextMenu(newOverlay, context);
        }
    };
    /**
     * @param {?} overlay
     * @param {?} context
     * @return {?}
     */
    ContextMenuService.prototype.attachContextMenu = /**
     * @param {?} overlay
     * @param {?} context
     * @return {?}
     */
    function (overlay, context) {
        var _this = this;
        var event = context.event, item = context.item, menuItems = context.menuItems, menuClass = context.menuClass;
        /** @type {?} */
        var contextMenuContent = overlay.attach(new ComponentPortal(ContextMenuContentComponent));
        contextMenuContent.instance.event = event;
        contextMenuContent.instance.item = item;
        contextMenuContent.instance.menuItems = menuItems;
        contextMenuContent.instance.overlay = overlay;
        contextMenuContent.instance.isLeaf = true;
        contextMenuContent.instance.menuClass = menuClass;
        ((/** @type {?} */ (overlay))).contextMenu = contextMenuContent.instance;
        /** @type {?} */
        var subscriptions = new Subscription();
        subscriptions.add(contextMenuContent.instance.execute.asObservable()
            .subscribe((/**
         * @param {?} executeEvent
         * @return {?}
         */
        function (executeEvent) { return _this.closeAllContextMenus(__assign({ eventType: 'execute' }, executeEvent)); })));
        subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()
            .subscribe((/**
         * @param {?} closeAllEvent
         * @return {?}
         */
        function (closeAllEvent) { return _this.closeAllContextMenus(__assign({ eventType: 'cancel' }, closeAllEvent)); })));
        subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()
            .subscribe((/**
         * @param {?} closeLeafMenuEvent
         * @return {?}
         */
        function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); })));
        subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()
            .subscribe((/**
         * @param {?} subMenuEvent
         * @return {?}
         */
        function (subMenuEvent) {
            _this.destroySubMenus(contextMenuContent.instance);
            if (!subMenuEvent.contextMenu) {
                contextMenuContent.instance.isLeaf = true;
                return;
            }
            contextMenuContent.instance.isLeaf = false;
            _this.show.next(subMenuEvent);
        })));
        contextMenuContent.onDestroy((/**
         * @return {?}
         */
        function () {
            menuItems.forEach((/**
             * @param {?} menuItem
             * @return {?}
             */
            function (menuItem) { return menuItem.isActive = false; }));
            subscriptions.unsubscribe();
        }));
        contextMenuContent.changeDetectorRef.detectChanges();
    };
    /**
     * @param {?} closeEvent
     * @return {?}
     */
    ContextMenuService.prototype.closeAllContextMenus = /**
     * @param {?} closeEvent
     * @return {?}
     */
    function (closeEvent) {
        if (this.overlays) {
            this.close.next(closeEvent);
            this.overlays.forEach((/**
             * @param {?} overlay
             * @param {?} index
             * @return {?}
             */
            function (overlay, index) {
                overlay.detach();
                overlay.dispose();
            }));
        }
        this.overlays = [];
    };
    /**
     * @return {?}
     */
    ContextMenuService.prototype.getLastAttachedOverlay = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var overlay = this.overlays[this.overlays.length - 1];
        while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {
            overlay.detach();
            overlay.dispose();
            this.overlays = this.overlays.slice(0, -1);
            overlay = this.overlays[this.overlays.length - 1];
        }
        return overlay;
    };
    /**
     * @param {?=} __0
     * @return {?}
     */
    ContextMenuService.prototype.destroyLeafMenu = /**
     * @param {?=} __0
     * @return {?}
     */
    function (_a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, exceptRootMenu = _b.exceptRootMenu, event = _b.event;
        if (this.isDestroyingLeafMenu) {
            return;
        }
        this.isDestroyingLeafMenu = true;
        setTimeout((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var overlay = _this.getLastAttachedOverlay();
            if (_this.overlays.length > 1 && overlay) {
                overlay.detach();
                overlay.dispose();
            }
            if (!exceptRootMenu && _this.overlays.length > 0 && overlay) {
                _this.close.next({ eventType: 'cancel', event: event });
                overlay.detach();
                overlay.dispose();
            }
            /** @type {?} */
            var newLeaf = _this.getLastAttachedOverlay();
            if (newLeaf) {
                newLeaf.contextMenu.isLeaf = true;
            }
            _this.isDestroyingLeafMenu = false;
        }));
    };
    /**
     * @param {?} contextMenu
     * @return {?}
     */
    ContextMenuService.prototype.destroySubMenus = /**
     * @param {?} contextMenu
     * @return {?}
     */
    function (contextMenu) {
        /** @type {?} */
        var overlay = contextMenu.overlay;
        /** @type {?} */
        var index = this.overlays.indexOf(overlay);
        this.overlays.slice(index + 1).forEach((/**
         * @param {?} subMenuOverlay
         * @return {?}
         */
        function (subMenuOverlay) {
            subMenuOverlay.detach();
            subMenuOverlay.dispose();
        }));
    };
    /**
     * @param {?} contextMenuContent
     * @return {?}
     */
    ContextMenuService.prototype.isLeafMenu = /**
     * @param {?} contextMenuContent
     * @return {?}
     */
    function (contextMenuContent) {
        /** @type {?} */
        var overlay = this.getLastAttachedOverlay();
        return contextMenuContent.overlay === overlay;
    };
    ContextMenuService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    ContextMenuService.ctorParameters = function () { return [
        { type: Overlay },
        { type: ScrollStrategyOptions }
    ]; };
    return ContextMenuService;
}());
if (false) {
    /** @type {?} */
    ContextMenuService.prototype.isDestroyingLeafMenu;
    /** @type {?} */
    ContextMenuService.prototype.show;
    /** @type {?} */
    ContextMenuService.prototype.triggerClose;
    /** @type {?} */
    ContextMenuService.prototype.close;
    /**
     * @type {?}
     * @private
     */
    ContextMenuService.prototype.contextMenuContent;
    /**
     * @type {?}
     * @private
     */
    ContextMenuService.prototype.overlays;
    /**
     * @type {?}
     * @private
     */
    ContextMenuService.prototype.fakeElement;
    /**
     * @type {?}
     * @private
     */
    ContextMenuService.prototype.overlay;
    /**
     * @type {?}
     * @private
     */
    ContextMenuService.prototype.scrollStrategy;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ILinkConfig$1() { }
if (false) {
    /** @type {?} */
    ILinkConfig$1.prototype.click;
    /** @type {?|undefined} */
    ILinkConfig$1.prototype.enabled;
    /** @type {?} */
    ILinkConfig$1.prototype.html;
}
/**
 * @record
 */
function MouseLocation() { }
if (false) {
    /** @type {?|undefined} */
    MouseLocation.prototype.left;
    /** @type {?|undefined} */
    MouseLocation.prototype.marginLeft;
    /** @type {?|undefined} */
    MouseLocation.prototype.marginTop;
    /** @type {?|undefined} */
    MouseLocation.prototype.top;
}
var ContextMenuComponent = /** @class */ (function () {
    function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {
        var _this = this;
        this._contextMenuService = _contextMenuService;
        this.changeDetector = changeDetector;
        this.elementRef = elementRef;
        this.options = options;
        this.menuClass = "";
        this.autoFocus = false;
        this.useBootstrap4 = false;
        this.disabled = false;
        this.close = new EventEmitter();
        this.open = new EventEmitter();
        this.visibleMenuItems = [];
        this.links = [];
        this.subscription = new Subscription();
        if (options) {
            this.autoFocus = options.autoFocus;
            this.useBootstrap4 = options.useBootstrap4;
        }
        this.subscription.add(_contextMenuService.show.subscribe((/**
         * @param {?} menuEvent
         * @return {?}
         */
        function (menuEvent) {
            _this.onMenuEvent(menuEvent);
        })));
    }
    /**
     * @return {?}
     */
    ContextMenuComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    /**
     * @param {?} menuEvent
     * @return {?}
     */
    ContextMenuComponent.prototype.onMenuEvent = /**
     * @param {?} menuEvent
     * @return {?}
     */
    function (menuEvent) {
        var _this = this;
        if (this.disabled) {
            return;
        }
        var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;
        if (contextMenu && contextMenu !== this) {
            return;
        }
        this.event = event;
        this.item = item;
        this.setVisibleMenuItems();
        this._contextMenuService.openContextMenu(__assign({}, menuEvent, { menuItems: this.visibleMenuItems, menuClass: this.menuClass }));
        this._contextMenuService.close.asObservable().pipe(first()).subscribe((/**
         * @param {?} closeEvent
         * @return {?}
         */
        function (closeEvent) { return _this.close.emit(closeEvent); }));
        this.open.next(menuEvent);
    };
    /**
     * @param {?} menuItem
     * @return {?}
     */
    ContextMenuComponent.prototype.isMenuItemVisible = /**
     * @param {?} menuItem
     * @return {?}
     */
    function (menuItem) {
        return this.evaluateIfFunction(menuItem.visible);
    };
    /**
     * @return {?}
     */
    ContextMenuComponent.prototype.setVisibleMenuItems = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.visibleMenuItems = this.menuItems.filter((/**
         * @param {?} menuItem
         * @return {?}
         */
        function (menuItem) { return _this.isMenuItemVisible(menuItem); }));
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ContextMenuComponent.prototype.evaluateIfFunction = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value instanceof Function) {
            return value(this.item);
        }
        return value;
    };
    ContextMenuComponent.decorators = [
        { type: Component, args: [{
                    encapsulation: ViewEncapsulation.None,
                    selector: 'context-menu',
                    template: " ",
                    styles: ["\n    .cdk-overlay-container {\n      position: fixed;\n      z-index: 1000;\n      pointer-events: none;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n    }\n    .ngx-contextmenu.cdk-overlay-pane {\n      position: absolute;\n      pointer-events: auto;\n      box-sizing: border-box;\n    }\n  "]
                }] }
    ];
    /** @nocollapse */
    ContextMenuComponent.ctorParameters = function () { return [
        { type: ContextMenuService },
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] }] }
    ]; };
    ContextMenuComponent.propDecorators = {
        menuClass: [{ type: Input }],
        autoFocus: [{ type: Input }],
        useBootstrap4: [{ type: Input }],
        disabled: [{ type: Input }],
        close: [{ type: Output }],
        open: [{ type: Output }],
        menuItems: [{ type: ContentChildren, args: [ContextMenuItemDirective,] }],
        menuElement: [{ type: ViewChild, args: ['menu', { static: false },] }]
    };
    return ContextMenuComponent;
}());
if (false) {
    /** @type {?} */
    ContextMenuComponent.prototype.menuClass;
    /** @type {?} */
    ContextMenuComponent.prototype.autoFocus;
    /** @type {?} */
    ContextMenuComponent.prototype.useBootstrap4;
    /** @type {?} */
    ContextMenuComponent.prototype.disabled;
    /** @type {?} */
    ContextMenuComponent.prototype.close;
    /** @type {?} */
    ContextMenuComponent.prototype.open;
    /** @type {?} */
    ContextMenuComponent.prototype.menuItems;
    /** @type {?} */
    ContextMenuComponent.prototype.menuElement;
    /** @type {?} */
    ContextMenuComponent.prototype.visibleMenuItems;
    /** @type {?} */
    ContextMenuComponent.prototype.links;
    /** @type {?} */
    ContextMenuComponent.prototype.item;
    /** @type {?} */
    ContextMenuComponent.prototype.event;
    /**
     * @type {?}
     * @private
     */
    ContextMenuComponent.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    ContextMenuComponent.prototype._contextMenuService;
    /**
     * @type {?}
     * @private
     */
    ContextMenuComponent.prototype.changeDetector;
    /**
     * @type {?}
     * @private
     */
    ContextMenuComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    ContextMenuComponent.prototype.options;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContextMenuAttachDirective = /** @class */ (function () {
    function ContextMenuAttachDirective(contextMenuService) {
        this.contextMenuService = contextMenuService;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    ContextMenuAttachDirective.prototype.onContextMenu = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.contextMenu.disabled) {
            this.contextMenuService.show.next({
                contextMenu: this.contextMenu,
                event: event,
                item: this.contextMenuSubject,
            });
            event.preventDefault();
            event.stopPropagation();
        }
    };
    ContextMenuAttachDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[contextMenu]',
                },] }
    ];
    /** @nocollapse */
    ContextMenuAttachDirective.ctorParameters = function () { return [
        { type: ContextMenuService }
    ]; };
    ContextMenuAttachDirective.propDecorators = {
        contextMenuSubject: [{ type: Input }],
        contextMenu: [{ type: Input }],
        onContextMenu: [{ type: HostListener, args: ['contextmenu', ['$event'],] }]
    };
    return ContextMenuAttachDirective;
}());
if (false) {
    /** @type {?} */
    ContextMenuAttachDirective.prototype.contextMenuSubject;
    /** @type {?} */
    ContextMenuAttachDirective.prototype.contextMenu;
    /**
     * @type {?}
     * @private
     */
    ContextMenuAttachDirective.prototype.contextMenuService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContextMenuModule = /** @class */ (function () {
    function ContextMenuModule() {
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    ContextMenuModule.forRoot = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        return {
            ngModule: ContextMenuModule,
            providers: [
                ContextMenuService,
                {
                    provide: CONTEXT_MENU_OPTIONS,
                    useValue: options,
                },
                { provide: OverlayContainer, useClass: FullscreenOverlayContainer },
            ],
        };
    };
    ContextMenuModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        ContextMenuAttachDirective,
                        ContextMenuComponent,
                        ContextMenuContentComponent,
                        ContextMenuItemDirective,
                    ],
                    entryComponents: [
                        ContextMenuContentComponent,
                    ],
                    exports: [
                        ContextMenuAttachDirective,
                        ContextMenuComponent,
                        ContextMenuItemDirective,
                    ],
                    imports: [
                        CommonModule,
                        OverlayModule,
                    ],
                },] }
    ];
    return ContextMenuModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function IContextMenuOptions() { }
if (false) {
    /** @type {?|undefined} */
    IContextMenuOptions.prototype.useBootstrap4;
    /** @type {?|undefined} */
    IContextMenuOptions.prototype.autoFocus;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ContextMenuComponent, ContextMenuModule, ContextMenuService, ContextMenuAttachDirective as ɵa, ContextMenuItemDirective as ɵb, CONTEXT_MENU_OPTIONS as ɵc, ContextMenuContentComponent as ɵd };
//# sourceMappingURL=ngx-contextmenu.js.map
